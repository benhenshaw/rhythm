# Memory Allocation (2018-02-15)
For my project, I have employed a very simple and fast method of memory management. It is centred around the concept of memory pools, which are stack-like structures that have a fixed amount of memory under their control. When an allocation is made from a pool, it selects some memory from the top of its pool and returns the address of that memory.

The allocated memory is also ensured to be aligned correctly for any type. This can be ensured by making the address of the returned pointer is a multiple of the largest alignment needed. There is a C language type called `maxalign_t`, and taking the size of this type will give you the maximum alignment needed. On two Intel machines I tested this gave 16 bytes. Not aligning correctly will only cause access to that memory to be slower, nothing fatal.

I have three memory pools, the persistent pool, scene pool, and frame pool. Each of which defines a lifetime of the memory it allocates. Any memory allocated by the persistent pool will live for the entire lifetime of the program. Scene pool allocated memory will live until the scene changes. The frame pool is reset after every frame. Individual allocations cannot be arbitrarily freed when allocated by a memory pool, all memory is deallocated when the pool is reset. One simply has to decide how long the allocation should last when allocating, and choose the appropriate pool.

This is a convenient way to manage memory as any functions that would like to allocate memory can ask the caller which pool they would like to use, giving more flexibility to the caller. It is also far faster than `malloc` or `new`, and as it does not have the concept of granular deallocation, and so does not force the overhead of `free`/`delete` on the caller.

The trade-off is that more memory may be allocated to the program than needed; although this is counteracted by the fact that operating systems don't actually allocate memory pages to programs until they attempt to write to them. This adds some overhead, so I may want to touch every allocated memory page at start up to ensure that is ready to go before an allocation is made. Overall this solution is better (faster, simpler), mostly because is is tailored to suit the needs of my game, and general purpose allocators are not.

The fixed amount of underlying memory managed by the pools is small enough (in my case) to comfortably allocate completely in static memory. Some research lead me to believe that 2GB is a reasonable maximum of static memory to assume (https://software.intel.com/en-us/articles/memory-limits-applications-windows).
