# Memory Allocation (2018-02-15)
For my project, I have employed a very simple and fast method of memory management. It is centred around the concept of memory pools, which are stack-like structures that have a fixed amount of memory under their control. When an allocation is made from a pool, it selects some memory from the top of its pool and returns the address of that memory.

I have three memory pools, the persistent pool, scene pool, and frame pool. Each of which defines a lifetime of the memory it allocates. Any memory allocated by the persistent pool will live for the entire lifetime of the program. Scene pool allocated memory will live until the scene changes. The frame pool is reset after every frame. Individual allocations cannot be arbitrarily freed when allocated by a memory pool, all memory is deallocated when the pool is reset. One simply has to decide how long the allocation should last when allocating, and choose the appropriate pool.

This is a convenient way to manage memory as any functions that would like to allocate memory can ask the caller which pool they would like to use, giving more flexibility to the caller. It is also far faster than `malloc` or `new`, and as it does not have the concept of granular deallocation, and so does not force the overhead of `free`/`delete` on the caller.

The fixed amount of underlying memory managed by the pools is small enough (in my case) to comfortably allocate completely in static memory. Some research lead me to believe that 2GB is a reasonable maximum of static memory to assume (https://software.intel.com/en-us/articles/memory-limits-applications-windows).
